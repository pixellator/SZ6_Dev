{% extends "base.html" %}
{% block title %}Game – WSZ6 Portal{% endblock %}

{% block extra_head %}
<style>
  .game-wrap      { display: grid; grid-template-columns: 3fr 1fr; gap: 1rem; align-items: start; }
  #state-display  { font-family: monospace; white-space: pre; background:#1e1e2e; color:#cdd6f4;
                    padding:1.2rem; border-radius:6px; font-size:1rem; line-height:1.5; min-height:8rem; }
  /* Shown instead of #state-display when the formulation provides vis_html. */
  #vis-display    { padding:.8rem; overflow:auto; }
  #ops-list       { list-style: none; }
  #ops-list li    { margin-bottom:.4rem; }
  #ops-list li button { width:100%; text-align:left; padding:.4rem .7rem; border-radius:4px;
                        border:none; cursor:pointer; font-size:.9rem; background:#f0f4f8; }
  #ops-list li button.applicable { background:#d4edda; color:#155724; }
  #ops-list li button.applicable:hover { background:#c3e6cb; }
  #ops-list li button:disabled { color:#aaa; cursor:not-allowed; }
  .my-turn-banner { background:#d4edda; color:#155724; padding:.5rem .8rem;
                    border-radius:4px; margin-bottom:.6rem; font-weight:600; }
  .wait-banner    { background:#fff3cd; color:#856404; padding:.5rem .8rem;
                    border-radius:4px; margin-bottom:.6rem; }
  #status-bar     { padding:.4rem .8rem; background:#e8f4fd; border-radius:4px;
                    font-size:.85rem; color:#0c5460; margin-bottom:.6rem; }
  /* Persistent current-message bar (never auto-hides). */
  #transition-msg { padding:.5rem .8rem; background:#f3e5f5; color:#4a148c;
                    border-radius:4px; margin-bottom:.6rem; min-height:2.4rem; }
  /* When empty (no transition yet) occupy space without showing the box. */
  #transition-msg:empty { background:transparent; padding:0; min-height:1.5rem; }
  /* Highlighted when a historical message is recalled. */
  #transition-msg.history-recall { background:#ede7f6; outline:2px solid #9c27b0; }

  /* ── Transition history panel ── */
  #transition-history { margin-top:.75rem; }
  #transition-history summary { cursor:pointer; padding:.35rem .6rem;
    background:#f0f4f8; border-radius:4px; user-select:none;
    color:#444; font-size:.85rem; }
  #transition-history summary:hover { background:#e4eaf0; }
  #history-list { margin:.4rem 0 0 0; padding:0 0 0 1.6rem;
    max-height:16rem; overflow-y:auto; border-left:3px solid #e0d0ee; }
  #history-list li { padding:.2rem .3rem; cursor:pointer;
    border-radius:3px; color:#555; margin-bottom:.15rem; font-size:.85rem; }
  #history-list li:hover { background:#f3e5f5; color:#4a148c; }
  #history-list li.selected { background:#e8d5f0; color:#4a148c; font-weight:600; }
  #goal-banner    { padding:.8rem 1rem; background:#d4edda; color:#155724;
                    border-radius:4px; font-size:1.1rem; font-weight:700; display:none; }
  #paused-banner  { padding:.8rem 1rem; background:#fff3cd; color:#856404;
                    border-radius:4px; font-size:1rem; font-weight:600; display:none; }

  /* ── Inline param form (int / float / str params) ── */
  #param-form     { margin-top:.6rem; padding:.8rem; background:#f0f4f8;
                    border:1px solid #d0d9e4; border-radius:4px; }
  #param-form label { display:block; font-size:.85rem; font-weight:600; margin-bottom:.2rem; }
  #param-form input { width:100%; padding:.3rem .5rem; border:1px solid #ccc;
                      border-radius:4px; font-size:.9rem; box-sizing:border-box; }
  .param-hint     { font-size:.75rem; color:#666; margin-top:.15rem; display:block; }

  /* ── File-edit modal overlay ── */
  #file-edit-overlay {
    position: fixed; inset: 0; z-index: 1000;
    background: rgba(0,0,0,.55);
    display: none;                     /* flex when open */
    align-items: center; justify-content: center;
  }
  #file-edit-modal {
    background: #fff; border-radius: 8px;
    width: min(860px, 92vw); height: min(82vh, 720px);
    display: flex; flex-direction: column;
    box-shadow: 0 8px 40px rgba(0,0,0,.3);
    animation: feSlideIn .15s ease;
  }
  @keyframes feSlideIn {
    from { opacity:0; transform:translateY(-12px); }
    to   { opacity:1; transform:translateY(0); }
  }
  #file-edit-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: .75rem 1.2rem; border-bottom: 1px solid #e0e0e0; flex-shrink: 0;
  }
  #file-edit-header h2 { margin:0; font-size:1rem; color:#1a3a5c; }
  #file-edit-wordcount { font-size:.82rem; color:#888; white-space:nowrap; }
  #file-edit-area {
    flex: 1; padding: 1.2rem 1.4rem;
    font-family: Georgia, 'Times New Roman', serif;
    font-size: 1.05rem; line-height: 1.75;
    border: none; resize: none; outline: none;
    color: #2c2c2c; background: #fefefe;
    overflow-y: auto;
  }
  #file-edit-footer {
    display: flex; align-items: center; justify-content: space-between;
    padding: .65rem 1.2rem; border-top: 1px solid #e0e0e0;
    background: #f8f9fa; border-radius: 0 0 8px 8px; flex-shrink: 0;
  }
  #file-edit-footer .hint { font-size:.8rem; color:#999; }
  #file-edit-footer .actions { display:flex; gap:.5rem; }

  @media (max-width:700px) { .game-wrap { grid-template-columns: 1fr; } }

  /* ── Full-screen overlay ── */
  #fs-overlay {
    position: fixed; inset: 0; z-index: 9999;
    background: #111;
    display: flex; align-items: center; justify-content: center;
  }
  /* vis-display sizing inside the overlay */
  #fs-overlay #vis-display {
    width: 100%; height: 100%;
    max-width: none; padding: 1.5rem;
    display: flex; align-items: center; justify-content: center;
    overflow: auto; box-sizing: border-box;
  }
  /* Scale SVGs to fill the overlay */
  #fs-overlay #vis-display svg { max-height: 90vh; width: 100%; }
  /* ✕ button — always visible top-right */
  #fs-close {
    position: absolute; top: .8rem; right: .8rem;
    background: rgba(255,255,255,.18); border: 1px solid rgba(255,255,255,.35);
    color: #fff; font-size: 1.1rem; line-height: 1;
    width: 2.2rem; height: 2.2rem; border-radius: 50%;
    cursor: pointer; z-index: 10000;
    display: flex; align-items: center; justify-content: center;
  }
  #fs-close:hover { background: rgba(255,255,255,.32); }
  /* Operator tray — slides up from bottom on pointer proximity */
  #fs-op-tray {
    position: absolute; bottom: 0; left: 0; right: 0;
    background: rgba(10,10,10,.82); backdrop-filter: blur(6px);
    padding: .65rem 1rem;
    transform: translateY(100%);
    transition: transform .28s ease;
    z-index: 10000;
  }
  #fs-op-tray.visible { transform: translateY(0); }
  #fs-ops-list { list-style: none; margin: 0; padding: 0;
                 display: flex; flex-wrap: wrap; gap: .4rem; }
  #fs-ops-list li button {
    background: rgba(255,255,255,.12); color: #eee;
    border: 1px solid rgba(255,255,255,.25); border-radius: 4px;
    padding: .35rem .75rem; cursor: pointer; font-size: .88rem;
  }
  #fs-ops-list li button.applicable {
    background: rgba(80,180,100,.35); border-color: rgba(100,220,120,.6); color: #dfffdf;
  }
  #fs-ops-list li button.applicable:hover { background: rgba(80,180,100,.55); }
  #fs-ops-list li button:disabled { opacity: .4; cursor: not-allowed; }
  /* Entry button (shown only when vis is active) */
  #fs-btn { margin-top: .5rem; display: none; }
</style>
{% endblock %}

{% block content %}
<h1 id="game-title">Game</h1>
<div id="status-bar">Connecting…</div>
<div id="transition-msg"></div>
<div id="goal-banner"></div>
<div id="paused-banner"></div>

<div class="game-wrap">

  <!-- Left: game state display -->
  <div>
    <div class="card" style="padding:0; overflow:hidden;">
      <div  id="vis-display"   style="display:none;"></div>
      <pre  id="state-display">Loading…</pre>
    </div>
    <button id="fs-btn" class="btn btn-sm"
            style="background:#444; color:#fff;"
            onclick="enterFullscreen()">&#x26F6; Full Screen</button>
    <div id="turn-banner" style="margin-top:.5rem;"></div>
    <details id="transition-history">
      <summary>Transition History (<span id="history-count">0</span> moves)</summary>
      <ol id="history-list"></ol>
    </details>
  </div>

  <!-- Right: operator list + controls -->
  <div class="card">
    <h2>Operators</h2>
    <ul id="ops-list"><li style="color:#aaa; font-style:italic; font-size:.9rem;">Waiting…</li></ul>

    <!-- Inline param form (int / float / str params) -->
    <div id="param-form" style="display:none;">
      <strong id="param-op-name" style="display:block; margin-bottom:.5rem; font-size:.9rem;"></strong>
      <div id="param-fields"></div>
      <div style="margin-top:.6rem;">
        <button class="btn btn-primary btn-sm" onclick="submitParams()">Apply</button>
        <button class="btn btn-sm" style="margin-left:.4rem; background:#e8ecf0;"
                onclick="cancelParams()">Cancel</button>
      </div>
    </div>

    <hr style="margin:1rem 0; border-color:#e0e0e0;">
    <button class="btn btn-warning btn-sm" onclick="sendUndo()" id="undo-btn" disabled>↩ Undo</button>
    <button class="btn btn-primary btn-sm" onclick="sendHelp()" style="margin-left:.4rem;">? Help</button>
    {% if is_owner %}
    <button class="btn btn-secondary btn-sm" onclick="sendPause()" id="pause-btn" style="margin-left:.4rem;">⏸ Pause</button>
    <button class="btn btn-success btn-sm" onclick="sendRematch()" id="rematch-btn" style="margin-left:.4rem; display:none;">↺ New Session with Same Players</button>
    {% endif %}
    <div id="help-msg" style="display:none; margin-top:.6rem; font-size:.85rem; color:#555;"></div>
  </div>

</div>

<!-- ── Full-screen vis overlay ──────────────────────────────────────── -->
<div id="fs-overlay" style="display:none;">
  <button id="fs-close" onclick="exitFullscreen()" title="Exit (Esc)">&#x2715;</button>
  <!-- #vis-display is moved here by enterFullscreen(), restored by exitFullscreen() -->
  <div id="fs-op-tray">
    <ul id="fs-ops-list"></ul>
  </div>
</div>

<!-- ── File-edit modal overlay ────────────────────────────────────────── -->
<!-- Clicking the backdrop (outside the modal) cancels the edit. -->
<div id="file-edit-overlay" onclick="if(event.target===this) cancelFileEdit();">
  <div id="file-edit-modal">

    <div id="file-edit-header">
      <h2 id="file-edit-title">Edit</h2>
      <span id="file-edit-wordcount">0 words</span>
    </div>

    <textarea id="file-edit-area" spellcheck="true"
              placeholder="Start writing here…"></textarea>

    <div id="file-edit-footer">
      <span class="hint">Ctrl+Enter to save</span>
      <div class="actions">
        <button class="btn btn-sm" style="background:#e8ecf0;"
                onclick="cancelFileEdit()">Cancel</button>
        <button class="btn btn-success btn-sm"
                onclick="saveFileEdit()">Save &amp; Apply</button>
      </div>
    </div>

  </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
(function() {
  const SESSION_KEY = "{{ session_key }}";
  const ROLE_TOKEN  = "{{ role_token }}";
  const WS_URL      = "{{ ws_url }}";

  let ws            = null;
  let myRoleNum     = -1;
  let gameOver      = false;
  let currentOps    = [];    // full operator list from the last state_update
  let pendingOpIndex = null; // op awaiting param input from the user
  let transitionHistory = []; // plain-text messages in arrival order

  // ── Full-screen state ─────────────────────────────────────────────
  let fsActive         = false;
  let fsVisParent      = null;   // #vis-display's original parentNode
  let fsVisNextSibling = null;   // original nextSibling for exact DOM restore
  let fsLastIsMyTurn   = false;  // replayed into renderFsOps on each state_update

  // ── File-edit modal setup (event listeners on static elements) ────────

  const feArea  = document.getElementById('file-edit-area');
  const feCount = document.getElementById('file-edit-wordcount');

  feArea.addEventListener('input', _updateWordCount);
  feArea.addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.key === 'Enter') { e.preventDefault(); saveFileEdit(); }
  });

  function _updateWordCount() {
    const text  = feArea.value.trim();
    const count = text ? text.split(/\s+/).length : 0;
    feCount.textContent = count + (count === 1 ? ' word' : ' words');
  }

  // ── Connection ──────────────────────────────────────────────────

  function connect() {
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    ws = new WebSocket(proto + '://' + location.host + WS_URL);
    ws.onopen    = () => setStatus('Connected.');
    ws.onmessage = (evt) => dispatch(JSON.parse(evt.data));
    ws.onerror   = ()  => setStatus('WebSocket error — try refreshing.');
    ws.onclose   = (e) => setStatus('Disconnected (code ' + e.code + ').');
  }

  function send(obj) {
    if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj));
  }

  // ── Message dispatch ─────────────────────────────────────────────

  function dispatch(msg) {
    if      (msg.type === 'state_update')      onStateUpdate(msg);
    else if (msg.type === 'transition_msg')    onTransition(msg);
    else if (msg.type === 'goal_reached')      onGoalReached(msg);
    else if (msg.type === 'game_paused')       onGamePaused(msg);
    else if (msg.type === 'new_session_ready') onNewSessionReady(msg);
    else if (msg.type === 'help')              showHelp(msg.message);
    else if (msg.type === 'error')             setStatus('⚠ ' + msg.message);
  }

  function onStateUpdate(msg) {
    myRoleNum  = msg.your_role_num;
    currentOps = msg.operators || [];

    // Dismiss any open input UI if a new state arrives externally.
    if (pendingOpIndex !== null) {
      hideParamForm();
      closeFileEditModal();
      pendingOpIndex = null;
    }

    // Prefer SVG/HTML vis if the formulation provides it; fall back to text.
    const visDisplay  = document.getElementById('vis-display');
    const textDisplay = document.getElementById('state-display');
    if (msg.vis_html) {
      visDisplay.innerHTML     = msg.vis_html;
      visDisplay.style.display = '';
      textDisplay.style.display = 'none';
    } else {
      textDisplay.textContent   = msg.state_text || JSON.stringify(msg.state, null, 2);
      textDisplay.style.display = '';
      visDisplay.style.display  = 'none';
    }

    // Show/hide the full-screen button; auto-exit if vis vanishes.
    const fsBtn = document.getElementById('fs-btn');
    if (msg.vis_html) {
      fsBtn.style.display = 'inline-block';
    } else {
      fsBtn.style.display = 'none';
      if (fsActive) exitFullscreen();
    }

    const isParallel = !!msg.is_parallel;
    // In parallel mode any player whose role-scoped operators are still
    // applicable can act; we don't gate on current_role_num.
    const hasApplicableOps = currentOps.some(op => op.applicable);
    const isMyTurn = !gameOver && !msg.is_goal && (
      isParallel ? hasApplicableOps : msg.current_role_num === myRoleNum
    );

    const turnBanner = document.getElementById('turn-banner');
    if (!gameOver && !msg.is_goal) {
      if (isParallel) {
        turnBanner.innerHTML = hasApplicableOps
          ? '<div class="my-turn-banner">Make your choice!</div>'
          : '<div class="wait-banner">Choice submitted — waiting for other player…</div>';
      } else {
        turnBanner.innerHTML = isMyTurn
          ? '<div class="my-turn-banner">Your turn!</div>'
          : '<div class="wait-banner">Waiting for another player…</div>';
      }
    }

    // Undo is always disabled during a parallel phase (and blocked server-side
    // for any move that came from a parallel state).
    document.getElementById('undo-btn').disabled =
      (msg.step === 0 || gameOver || msg.is_goal || isParallel);
    setStatus('Step ' + msg.step + (msg.is_goal ? ' — Goal reached!' : ''));
    renderOps(msg.operators, isMyTurn);
    fsLastIsMyTurn = isMyTurn;
    if (fsActive) renderFsOps(currentOps, isMyTurn);

    if (msg.is_goal && !gameOver) {
      gameOver = true;
      document.getElementById('turn-banner').innerHTML = '';
      showGoal('Goal reached at step ' + msg.step + '!');
    }
  }

  function onTransition(msg) {
    // Show persistently — no auto-dismiss.
    const el = document.getElementById('transition-msg');
    el.textContent = msg.message;
    // If a historical recall was showing, clear its highlight.
    el.classList.remove('history-recall');
    document.querySelectorAll('#history-list li.selected')
      .forEach(l => l.classList.remove('selected'));

    // Append to history list.
    transitionHistory.push(msg.message);
    const idx = transitionHistory.length - 1;
    const list = document.getElementById('history-list');
    const li = document.createElement('li');
    li.dataset.idx = idx;
    li.textContent = msg.message;
    li.title = 'Click to re-display';
    li.addEventListener('click', function() { recallHistoryItem(this); });
    list.appendChild(li);
    list.scrollTop = list.scrollHeight; // keep newest visible

    document.getElementById('history-count').textContent = transitionHistory.length;
  }

  function recallHistoryItem(liEl) {
    // Show a past message in the current-message bar with a visual indicator.
    // It stays until the next real transition arrives.
    const text = transitionHistory[parseInt(liEl.dataset.idx)];
    if (text === undefined) return;
    const el = document.getElementById('transition-msg');
    el.textContent = text;
    el.classList.add('history-recall');
    document.querySelectorAll('#history-list li.selected')
      .forEach(l => l.classList.remove('selected'));
    liEl.classList.add('selected');
  }

  // ── Full-screen enter / exit ──────────────────────────────────────

  window.enterFullscreen = function() {
    if (fsActive) return;
    const visEl = document.getElementById('vis-display');
    if (!visEl || visEl.style.display === 'none') return;

    fsVisParent      = visEl.parentNode;
    fsVisNextSibling = visEl.nextSibling;
    fsActive         = true;

    const overlay = document.getElementById('fs-overlay');
    // Insert vis-display just before the tray (after #fs-close)
    const tray = document.getElementById('fs-op-tray');
    overlay.insertBefore(visEl, tray);
    overlay.style.display = 'flex';

    renderFsOps(currentOps, fsLastIsMyTurn);
    document.addEventListener('keydown', _onFsKey);
  };

  window.exitFullscreen = function() {
    if (!fsActive) return;
    fsActive = false;

    const visEl   = document.getElementById('vis-display');
    const overlay = document.getElementById('fs-overlay');

    // Restore vis-display to its exact original DOM position.
    if (fsVisNextSibling) {
      fsVisParent.insertBefore(visEl, fsVisNextSibling);
    } else {
      fsVisParent.appendChild(visEl);
    }

    overlay.style.display = 'none';
    document.getElementById('fs-op-tray').classList.remove('visible');
    document.removeEventListener('keydown', _onFsKey);
  };

  function _onFsKey(e) {
    if (e.key === 'Escape') exitFullscreen();
  }

  // Reveal tray when pointer enters the bottom 12% of the overlay.
  (function() {
    const overlay = document.getElementById('fs-overlay');
    overlay.addEventListener('pointermove', function(e) {
      if (!fsActive) return;
      const tray   = document.getElementById('fs-op-tray');
      const thresh = overlay.clientHeight * 0.88;
      if (e.clientY >= thresh) tray.classList.add('visible');
      else                     tray.classList.remove('visible');
    });
  })();

  function onGoalReached(msg) {
    gameOver = true;
    showGoal(msg.goal_message || 'Goal reached!');
    renderOps([], false);
    document.getElementById('undo-btn').disabled = true;
    const pauseBtn = document.getElementById('pause-btn');
    if (pauseBtn) pauseBtn.disabled = true;
    const rematchBtn = document.getElementById('rematch-btn');
    if (rematchBtn) rematchBtn.style.display = 'inline-block';
  }

  function onNewSessionReady(msg) {
    setStatus('New session ready — redirecting to lobby…');
    window.location.href = msg.lobby_url;
  }

  function onGamePaused(msg) {
    gameOver = true;
    renderOps([], false);
    document.getElementById('undo-btn').disabled = true;
    const pauseBtn = document.getElementById('pause-btn');
    if (pauseBtn) pauseBtn.disabled = true;
    document.getElementById('turn-banner').innerHTML = '';
    const lobbyUrl = '/play/join/' + SESSION_KEY + '/';
    const banner = document.getElementById('paused-banner');
    banner.innerHTML = '⏸ Game paused at step ' + msg.step +
      '. <a href="' + lobbyUrl + '">Go to lobby to resume.</a>';
    banner.style.display = 'block';
    setStatus('Game paused (checkpoint saved).');
  }

  // ── Rendering ────────────────────────────────────────────────────

  function renderOps(ops, isMyTurn) {
    const list = document.getElementById('ops-list');
    if (!ops || ops.length === 0) {
      list.innerHTML =
        '<li style="color:#aaa; font-style:italic; font-size:.9rem;">No operators available</li>';
      return;
    }
    let html = '';
    for (const op of ops) {
      const canApply = isMyTurn && op.applicable;
      const hasParams = op.params && op.params.length > 0;
      const isFileEdit = hasParams && op.params.some(p => p.type === 'file_edit');
      // ✎ for file-edit ops, ▸ for other parameterized ops
      const hint = isFileEdit
        ? ' <span style="font-size:.75rem;opacity:.65;" title="Opens text editor">✎</span>'
        : hasParams
          ? ' <span style="font-size:.7rem;opacity:.6;" title="Requires input">▸</span>'
          : '';
      html += `<li>
        <button class="${canApply ? 'applicable' : ''}"
                onclick="applyOp(${op.index})"
                ${canApply ? '' : 'disabled'}>
          ${esc(op.name)}${hint}
        </button>
      </li>`;
    }
    list.innerHTML = html;
  }

  function renderFsOps(ops, isMyTurn) {
    const list = document.getElementById('fs-ops-list');
    if (!list) return;
    if (!ops || ops.length === 0) {
      list.innerHTML =
        '<li style="color:#aaa; font-style:italic; font-size:.85rem;">No operators</li>';
      return;
    }
    let html = '';
    for (const op of ops) {
      const canApply = isMyTurn && op.applicable;
      html += `<li><button class="${canApply ? 'applicable' : ''}"
                   onclick="applyOp(${op.index})"
                   ${canApply ? '' : 'disabled'}>${esc(op.name)}</button></li>`;
    }
    list.innerHTML = html;
  }

  function showGoal(msg) {
    const el = document.getElementById('goal-banner');
    el.textContent = msg;
    el.style.display = 'block';
  }

  function showHelp(msg) {
    const el = document.getElementById('help-msg');
    el.textContent = msg;
    el.style.display = 'block';
  }

  // ── User action: apply operator ───────────────────────────────────

  window.applyOp = function(opIndex) {
    const op = currentOps.find(o => o.index === opIndex);
    if (!op || !op.params || op.params.length === 0) {
      send({ type: 'apply_operator', op_index: opIndex });
      return;
    }
    pendingOpIndex = opIndex;
    // Route to file-edit modal or inline param form.
    if (op.params.some(p => p.type === 'file_edit')) {
      openFileEditModal(op);
    } else {
      showParamForm(op.name, op.params);
    }
  };

  // ── File-edit modal ───────────────────────────────────────────────

  function openFileEditModal(op) {
    const feParam = op.params.find(p => p.type === 'file_edit');
    const initial = (feParam && feParam.initial_text) || '';

    document.getElementById('file-edit-title').textContent = op.name;
    feArea.value = initial;
    _updateWordCount();

    const overlay = document.getElementById('file-edit-overlay');
    overlay.style.display = 'flex';
    feArea.focus();
    feArea.setSelectionRange(0, 0);
    feArea.scrollTop = 0;
  }

  function closeFileEditModal() {
    document.getElementById('file-edit-overlay').style.display = 'none';
    feArea.value = '';
    _updateWordCount();
  }

  window.saveFileEdit = function() {
    const content = feArea.value;
    const idx     = pendingOpIndex;
    closeFileEditModal();
    pendingOpIndex = null;
    send({ type: 'apply_operator', op_index: idx, args: [content] });
  };

  window.cancelFileEdit = function() {
    closeFileEditModal();
    pendingOpIndex = null;
  };

  // ── Inline param form (int / float / str) ─────────────────────────

  function showParamForm(opName, params) {
    document.getElementById('param-op-name').textContent = opName;
    const fields = document.getElementById('param-fields');
    let html = '';
    for (let i = 0; i < params.length; i++) {
      const p     = params[i];
      const label = p.name || ('Parameter ' + (i + 1));
      html += '<div style="margin-bottom:.6rem;">';
      html += '<label>' + esc(label) + '</label>';
      if (p.type === 'int') {
        const minA = (p.min !== undefined) ? ' min="' + p.min + '"' : '';
        const maxA = (p.max !== undefined) ? ' max="' + p.max + '"' : '';
        html += '<input id="param-' + i + '" type="number" step="1"' + minA + maxA + '>';
        if (p.min !== undefined && p.max !== undefined) {
          html += '<span class="param-hint">Range: ' + p.min + ' – ' + p.max + '</span>';
        }
      } else if (p.type === 'float') {
        const minA = (p.min !== undefined) ? ' min="' + p.min + '"' : '';
        const maxA = (p.max !== undefined) ? ' max="' + p.max + '"' : '';
        html += '<input id="param-' + i + '" type="number" step="any"' + minA + maxA + '>';
        if (p.min !== undefined && p.max !== undefined) {
          html += '<span class="param-hint">Range: ' + p.min + ' – ' + p.max + '</span>';
        }
      } else {
        html += '<input id="param-' + i + '" type="text">';
      }
      html += '</div>';
    }
    fields.innerHTML = html;
    document.getElementById('param-form').style.display = 'block';
    const first = document.getElementById('param-0');
    if (first) { first.focus(); if (first.select) first.select(); }
  }

  function hideParamForm() {
    document.getElementById('param-form').style.display = 'none';
    document.getElementById('param-fields').innerHTML = '';
  }

  window.submitParams = function() {
    if (pendingOpIndex === null) return;
    const op = currentOps.find(o => o.index === pendingOpIndex);
    if (!op) return;
    const params = op.params || [];
    const args = [];
    for (let i = 0; i < params.length; i++) {
      const p  = params[i];
      const el = document.getElementById('param-' + i);
      if (!el) { args.push(null); continue; }
      el.style.borderColor = '';
      if (p.type === 'int') {
        const v = parseInt(el.value, 10);
        if (isNaN(v))                         { _paramErr(el); return; }
        if (p.min !== undefined && v < p.min) { _paramErr(el); return; }
        if (p.max !== undefined && v > p.max) { _paramErr(el); return; }
        args.push(v);
      } else if (p.type === 'float') {
        const v = parseFloat(el.value);
        if (isNaN(v))                         { _paramErr(el); return; }
        if (p.min !== undefined && v < p.min) { _paramErr(el); return; }
        if (p.max !== undefined && v > p.max) { _paramErr(el); return; }
        args.push(v);
      } else {
        args.push(el.value);
      }
    }
    const idx = pendingOpIndex;
    hideParamForm();
    pendingOpIndex = null;
    send({ type: 'apply_operator', op_index: idx, args: args });
  };

  function _paramErr(el) { el.style.borderColor = '#dc3545'; el.focus(); }

  window.cancelParams = function() {
    hideParamForm();
    pendingOpIndex = null;
  };

  // ── Other controls ────────────────────────────────────────────────

  window.sendUndo = function() { send({ type: 'request_undo' }); };

  window.sendHelp = function() { send({ type: 'request_help' }); };

  window.sendPause = function() {
    if (confirm('Pause the game? All players will be disconnected from the game page.')) {
      send({ type: 'request_pause' });
      document.getElementById('pause-btn').disabled = true;
    }
  };

  window.sendRematch = function() {
    send({ type: 'request_rematch' });
    const rematchBtn = document.getElementById('rematch-btn');
    if (rematchBtn) rematchBtn.disabled = true;
  };

  function setStatus(msg) { document.getElementById('status-bar').textContent = msg; }

  function esc(str) {
    const d = document.createElement('div'); d.textContent = String(str); return d.innerHTML;
  }

  connect();
})();
</script>
{% endblock %}
